function HTCondor_mat2csv(ResultDir, varargin)
% HTCondorLoad Load results from a collection of HTCondor jobs.
%   [params] = HTCondorLoad(ResultDir); avoids loading any data.
%   [params, results] = HTCondorLoad(ResultDir);
%   [params, results] = HTCondorLoad(ResultDir, varargin);
%
%   OPTIONS:
%   ResultFile : The name of the file written by the HTCondor job. Will
%                contain a structure.
%   ParamFile  : The name of the json file that defines the job.
%   SortJobs   : Will ensure that the internal list of job directories is
%                sorted by directory name before loading any data.
%   SkipFields : A cell array of field names in the results structure. Any
%                field name listed here will not be loaded. Useful if there
%                are large data elements that you do not need. Controls
%                memory footprint and speeds access.
%   JobList    : A list of job directory names to load.
%
%  DEPENDENCIES:
%  - JSONlab http://www.mathworks.com/matlabcentral/fileexchange/33381
    p = inputParser();
    addRequired(p,'ResultStruct', @isstruct);
    addRequired(p,'OutputFile', @ischar);
    addParameter(p,'SortJobs',false,@islogical)
    addParameter(p,'correct_nzv',0,@isnumeric)
    addParameter(p,'SkipFields',{})
    addParameter(p,'IncludeFields',{})
    addParameter(p,'JobList',{},@iscellstr)
    addParameter(p,'quiet',false,@islogical)
    parse(p,ResultDir, varargin{:});

    RESULT_STRUCT  = p.Results.ResultStruct;
    OUTPUT_FILE = p.Results.OutputFile;
    SKIP        = p.Results.SkipFields;
    INCLUDE     = p.Results.IncludeFields;

    if ~isempty(SKIP) && ~isempty(INCLUDE)
        error('Both SKIP and INCLUDE cannot be set.')
    elseif ~isempty(SKIP) && isempty(INCLUDE)
        SkipStr = SKIP;
        SkipStr{end} = ['and ', SKIP{end}];
        SkipStr = strjoin(SkipStr, ', ');
        fprintf('Fields %s will be skipped.\n', SkipStr);
    elseif isempty(SKIP) && ~isempty(INCLUDE)
        InclStr = INCLUDE;
        InclStr{end} = ['and ', INCLUDE{end}];
        InclStr = strjoin(InclStr, ', ');
        fprintf('Fields %s will be Included.\n', InclStr);
    end

    R = RESULT_STRUCT;
    if ~isempty(INCLUDE) && isempty(SKIP)
        SKIP = fieldnames(rmfield(R,INCLUDE));
    end
    z = ismember(SKIP,fieldnames(R));
    R = rmfield(R, SKIP(z));
    [fmt,fmt_h] = fieldfmt(fieldnames(R));

    fid = fopen(OUTPUT_FILE, 'w');
    header = fieldnames(R);
    fprintf(fid, fmt_h, header{:});
    for i = 1:size(R,1)
        rc = squeeze(struct2cell(R(i,:)));    
        for j = 1:size(rc,2)
            xc = rc(:,j);
            for k = 1:size(rc,1);
                if isinteger(rc(k,j))
                    xc{k} = double(rc(k,j));
                end
            end
            fprintf(fid, fmt, xc{:});
        end
    end
    fclose(fid);
end

function [fmt,fmt_h] = fieldfmt(fieldnames)
    % List all possible fields and their desired format code
    fieldFMT = struct( ...
        'iter'         , '%d'   , ...
        'job'          , '%d'   , ...
        'subject'      , '%d'   , ...
        'finalholdout' , '%d'   , ...
        'cvholdout'    , '%d'   , ...
        'cvscheme'     , '%d'   , ...
        'condition'    , '%s'   , ...
        'data'         , '%s'   , ...
        'data_var'     , '%s'   , ...
        'data_varname' , '%s'   , ...
        'metadata'     , '%s'   , ...
        'metadata_var' , '%s'   , ...
        'metadata_varname' , '%s'   , ...
        'target'       , '%s'   , ...
        'target_type'  , '%s'   , ...
        'target_label' , '%s'   , ...
        'sim_source'   , '%s'   , ...
        'sim_metric'   , '%s'   , ...
        'Gtype'        , '%s'   , ...
        'regularization', '%s'   , ...
        'shape'        , '%s'   , ...
        'alpha'        , '%.4f' , ...
        'lambda'       , '%.4f' , ...
        'lambda1'      , '%.4f' , ...
        'LambdaSeq'    , '%s'   , ...
        'diameter'     , '%d'   , ...
        'overlap'     , '%d'   , ...
        'tau'          , '%.4f' , ...
        'normalize'    , '%s'   , ...
        'normalize_data', '%s'   , ...
        'normalize_target', '%s'   , ...
        'normalizewrt', '%s'   , ...
        'normalize_wrt', '%s'   , ...
        'target_normalization'    , '%s'   , ...
        'bias'         , '%d'   , ...
        'RandomSeed'   , '%d'   , ...
        'nVoxel'       , '%d'   , ...
        'h1'           , '%d' , ...
        'h2'           , '%d' , ...
        'f1'           , '%d' , ...
        'f2'           , '%d' , ...
        'nt1'          , '%d' , ...
        'nt2'          , '%d' , ...
        'nd1'          , '%d' , ...
        'nd2'          , '%d' , ...
        'iterations'   , '%d' , ...
        'p1'           , '%.4f' , ...
        'p2'           , '%.4f' , ...
        'cor1'         , '%.4f' , ...
        'cor2'         , '%.4f' , ...
        'err1'         , '%.4f' , ...
        'err2'         , '%.4f' , ...
        'FroErr1'      , '%.4f' , ...
        'FroErr2'      , '%.4f' , ...
        'nvox'         , '%d'   , ...
        'Wnz'          , '%d'   , ...
        'BoxCar'       , '%d'   , ...
        'WindowSize'   , '%d'   , ...
        'WindowStart'  , '%d'   , ...
        'nzvox'        , '%d'   , ...
        'nzv'          , '%d');

    fmt_c = cell(1,numel(fieldnames));
    for i = 1:numel(fieldnames)
        fmt_c{i} = fieldFMT.(fieldnames{i});
    end
    fmt = [strjoin(fmt_c,',') '\n'];
    fmt_h = [strjoin(repmat({'%s'},1,numel(fieldnames)),',') '\n'];
end
